# `build:command`相关

```json
"build:file": "node build/bin/iconInit.js & node build/bin/build-entry.js & node build/bin/i18n.js & node build/bin/version.js",

"build:theme": "node build/bin/gen-cssfile && gulp build --gulpfile packages/theme-chalk/gulpfile.js && cp-cli packages/theme-chalk/lib lib/theme-chalk",

"build:utils": "cross-env BABEL_ENV=utils babel src --out-dir lib --ignore src/index.js",

"build:umd": "node build/bin/build-locale.js",
```



## `build:file`构建文件

> `build:file`用`&`连起来4句命令，表示这4句是有执行顺序的。需要前面一句命令执行完，才会执行下一句命令。`&&`则是同步执行

### `node build/bin/iconInit.js`, 输出icon数组

获取`theme-chalk/src/icon.scss`文件夹，解析出icon的class名，并输出为一个数组，到`examples/icon.json`文件

![image-20200911143209626](https://raw.githubusercontent.com/Charming2015/picture-hosting/master/img/20200915184430.png)



### `node build/bin/build-entry.js`,

获取`root/components.json`文件里面的组件数据，经过模板编译，输出到`src/index.js`文件里。

![image-20200911145647033](https://raw.githubusercontent.com/Charming2015/picture-hosting/master/img/20200915184431.png)

打开`src/index.js`可以看到文件开头是注明了:

```javascript
/* Automatically generated by './build/bin/build-entry.js' */
```



### `node build/bin/i18n.js`

> === npm run i18n



获取`root/examples/i18n/page.json`里的配置，以`examples/pages/template/[pageName].tpl`为模板，生成不同语言的文件夹。



`page.json`格式说明

```
[
	{
		"lang": "zh-CN",
		"pages": {
			"pageName": { // pageName对应template文件夹里面的模板文件
				[key]: value
			}
		}
	}, {
		"lange": "es" // 其他语言
	}
]
```



![image-20200911150211479](https://raw.githubusercontent.com/Charming2015/picture-hosting/master/img/20200915184432.png)



### `node build/bin/version.js`

把版本信息输出到`examples/versions.json`文件，会具有一一对应关系

![image-20200911151204564](https://raw.githubusercontent.com/Charming2015/picture-hosting/master/img/20200915184433.png)

这个文件看得比较尴尬，感觉前面几个文件都是大型机械式生产，到了这个文件感觉回到了解放前。



可能因为版本号的确比较难订吧，因为每次合并到master都会打一个tag，但是很难说准真正发版的是哪个版本。



## `build:theme`构建主题

> 这几句命令没有先后关系，可以同时执行

### `node build/bin/gen-cssfile`

根据`root/components.json`的组件情况，来输出`packages/theme-chalk/index.js`里，引入各个组件的scss文件是



这里有几个点要注意的是

1. 会跳过icon,option,option-group这三个scss【TODO】为啥跳过option和option-group？
2. 会自动创建缺失的scss文件。（component存在，但是scss缺失的）

![image-20200911153609215](https://raw.githubusercontent.com/Charming2015/picture-hosting/master/img/20200915184434.png)

### `gulp build --gulpfile packages/theme-chalk/gulpfile.js`

这里有的不一样的是构建命令的文件不再在build目录下了，为啥直接在`packages/theme-chalk`下的`gulpfile.js`文件。注意一下说明有些都是相对路径。



主要是把src下所有scss文件，编译，压缩，输出到`./lib`下。第二是把`./src/fonts`里所有的文件都压缩。输出到`./lib/fonts`

![image-20200911154239845](https://raw.githubusercontent.com/Charming2015/picture-hosting/master/img/20200915184435.png)



### `cp-cli packages/theme-chalk/lib lib/theme-chalk`

这个就是把`packages/theme-chalk/lib`目录，复制到`lib/theme-chalk`里



## `build:utils`构建工具函数

就是把src文件里的，（除了src/index.js），都babel一下。

### `cross-env BABEL_ENV=utils babel src --out-dir lib --ignore src/index.js`

env变量utils，与.babelrc里的配置相呼应。（可知还有一个变量是test）

![image-20200911154804806](https://raw.githubusercontent.com/Charming2015/picture-hosting/master/img/20200915184436.png)



## `build:umd`构建cmd格式的文件



### `node build/bin/build-locale.js`

生成umd格式的各种语言字典



----



# dist打包输出

```javascript
"dist": "npm run clean 
&& npm run build:file 
&& npm run lint 
&& webpack --config build/webpack.conf.js 
&& webpack --config build/webpack.common.js 
&& webpack --config build/webpack.component.js 
&& npm run build:utils 
&& npm run build:umd 
&& npm run build:theme",
```

## dist

### `npm run clean`

= `rimraf lib && rimraf packages/*/lib && rimraf test/**/coverage`

清空相关文件



### `npm run build:file`

打包文件



### `npm run lint`

修复风格



### `webpack --config build/webpack.conf.js`

入口：src/index.js

输出：lib/index.js



### `webpack --config build/webpack.common.js`

入口：src/index.js

输出：lib/element-ui.common.js





### `webpack --config build/webpack.component.js`

入口：各component的index.js

输出：lib/[componentName].js



### `npm run build:utils`

打包工具函数



### `npm run build:umd`

打包成umd格式文件



### `npm run build:theme`

打包主题文件

----



【STAR】

1. fileExists函数可以参考

```javascript
function fileExists(filePath) {
  try {
    return fs.statSync(filePath).isFile();
  } catch (err) {
    return false;
  }
}
```



【TODO】

1. webpack.conf.js与webpack.common.js的区别